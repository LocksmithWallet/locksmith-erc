// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import {
    BadSessionAccount,
    ExistingSession,
    InsufficientAllowance,
    Unauthorized,
    UnauthorizedDestination
} from "../src/BadSessionAccount.sol";
import { ShadowERC } from 'test/ShadowERC.sol';
import { Puller } from 'test/Puller.sol';

import "openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol";
import "openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol";
using EnumerableSet for EnumerableSet.AddressSet;

contract VulnerabilityTests is Test, ERC1155Holder {
    BadSessionAccount public account;
    ShadowERC public erc20; 
    Puller public puller;

    string public constant mnemonic = "test test test test test test test test test test test junk"; 

    address public second;

    address[] public emptyDestinations;
    EnumerableSet.AddressSet private destinations;
    EnumerableSet.AddressSet private onlyERC20;

    receive() external payable { 
        // needed to be able to take money
    }

    function setUp() public {
        // create the account
        account = new BadSessionAccount();
      
        // create the tokens
        erc20 = new ShadowERC('Link', 'LINK');
        erc20.spawn(1 ether);
        
        // generate the "uniswap" puller
        puller = new Puller(address(erc20));

        // prepare a second operator in case we need to prank
        second = vm.addr(vm.deriveKey(mnemonic, 0));

        // fund this test, and the account
        vm.deal(address(this), 10 ether);
        (bool success,) = address(account).call{value: 1 ether}("");
        assert(success);

        // generate some test data
        destinations.add(address(puller));
        onlyERC20.add(address(erc20));
    }

    function test_AllowanceLeaksAcrossSessions() public {
        // fund the account
        erc20.transfer(address(account), 1 ether);
        assertEq(erc20.balanceOf(second), 0 ether);
        assertEq(erc20.balanceOf(address(account)), 1 ether);

        // create session 1, which can access it
        account.createKey(1, address(this));
        account.createSession(1, onlyERC20.values(), 0);

        // create session 2, which can only access a single external contract
        account.createKey(2, address(this));
        account.createSession(2, destinations.values(), 0);

        // demonstrate that contract fails as it should, by trying to use
        // the puller even though there won't be an allowance on the account
        vm.expectRevert();
        account.execute(2, address(puller), 0, abi.encodeWithSelector(puller.pull.selector));
        assertEq(erc20.balanceOf(address(account)), 1 ether);

        // use session 1 to set an allowance that leaks outside the session.
        // This simulates a session setting a token approval for something like uniswap.
        // This user has "access" to this ERC20. It's entirely possible a user could
        // set the approval to "infinite" as well. In either case, this allowance
        // is going to immmediately leak across sessions for the entire account.
        account.execute(1, address(erc20), 0,
            abi.encodeWithSelector(erc20.approve.selector, address(puller), 1 ether));

        // demonstrate that the contract doesn't fail, and the funds could
        // be utilized even though the session isn't configured for it
        // If the account session model was secure, this would FAIL, as the session
        // shouldn't have access to utilize that ERC20, but will because of state left
        // over from other sessions
        account.execute(2, address(puller), 0, abi.encodeWithSelector(puller.pull.selector));
        assertEq(erc20.balanceOf(address(account)), 0 ether);
        assertEq(erc20.balanceOf(address(puller)), 1 ether);
    }

    function test_StoringSessionsInAccountCausesPrivilegeEscalation() public {
        // fund the account with ERC20
        erc20.transfer(address(account), 1 ether);
        assertEq(erc20.balanceOf(address(account)), 1 ether);
        assertEq(erc20.balanceOf(second), 0 ether);

        // create session 1, which can access the ERC20
        account.createKey(1, address(this));
        account.createSession(1, onlyERC20.values(), 0);

        // deposit the session key into the account
        account.safeTransferFrom(address(this), address(account), 1, 1, '');
        assertEq(account.balanceOf(address(account), 1), 1);

        // create a session with just ether allowance, which they
        // can seemingly just use. problem is, there is a session key held
        // in the account, which is going to have bad ramifications:
        //
        // 1) This session could MOVE any session key out of the account.
        // 2) This session could, without moving it (assuming maybe the key was soulbind),
        //    re-enter the contract as the contract itself and re-use the session.
        account.createKey(2, address(this));
        account.createSession(2, emptyDestinations, 1 ether);
    
        // use the "ether only" session to re-enter the contract,
        // using privilege escalation to use the ERC20s
        account.execute(2, address(account), 0,
                abi.encodeWithSelector(account.execute.selector, 1, address(erc20), 0,
                    abi.encodeWithSelector(erc20.transfer.selector, second, 1 ether)));

        // assert that the ERC20s have moved
        assertEq(erc20.balanceOf(address(account)), 0 ether);
        assertEq(erc20.balanceOf(second), 1 ether);
    }
}
